import inspect
import re


def do_find(f, mod):
    import linecache
<<<<<<< HEAD

=======
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    if inspect.ismodule(mod):
        return f, 0, 0

    lines = linecache.getlines(f)

    if inspect.isclass(mod):
        name = mod.__name__
<<<<<<< HEAD
        pat = re.compile(r"^\s*class\s*" + name + r"\b")
=======
        pat = re.compile(r'^\s*class\s*' + name + r'\b')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
        for i in range(len(lines)):
            if pat.match(lines[i]):
                return f, i, 0

        return f, 0, 0

    if inspect.ismethod(mod):
        mod = mod.im_func

    if inspect.isfunction(mod):
        try:
            mod = mod.func_code
        except AttributeError:
            mod = mod.__code__  # python 3k

    if inspect.istraceback(mod):
        mod = mod.tb_frame

    if inspect.isframe(mod):
        mod = mod.f_code

    if inspect.iscode(mod):
<<<<<<< HEAD
        if not hasattr(mod, "co_filename"):
            return None, 0, 0

        if not hasattr(mod, "co_firstlineno"):
            return mod.co_filename, 0, 0

        lnum = mod.co_firstlineno
        pat = re.compile(r"^(\s*def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)")
=======
        if not hasattr(mod, 'co_filename'):
            return None, 0, 0

        if not hasattr(mod, 'co_firstlineno'):
            return mod.co_filename, 0, 0

        lnum = mod.co_firstlineno
        pat = re.compile(r'^(\s*def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
        while lnum > 0:
            if pat.match(lines[lnum]):
                break
            lnum -= 1

        return f, lnum, 0

<<<<<<< HEAD
    raise RuntimeError("Do not know about: " + f + " " + str(mod))
=======
    raise RuntimeError('Do not know about: ' + f + ' ' + str(mod))
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
