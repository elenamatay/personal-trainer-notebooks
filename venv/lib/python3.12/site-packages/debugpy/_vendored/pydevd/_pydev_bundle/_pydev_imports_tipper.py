import inspect
import os.path
import sys

from _pydev_bundle._pydev_tipper_common import do_find
from _pydevd_bundle.pydevd_utils import hasattr_checked, dir_checked

from inspect import getfullargspec


def getargspec(*args, **kwargs):
    arg_spec = getfullargspec(*args, **kwargs)
    return arg_spec.args, arg_spec.varargs, arg_spec.varkw, arg_spec.defaults, arg_spec.kwonlyargs or [], arg_spec.kwonlydefaults or {}


# completion types.
<<<<<<< HEAD
TYPE_IMPORT = "0"
TYPE_CLASS = "1"
TYPE_FUNCTION = "2"
TYPE_ATTR = "3"
TYPE_BUILTIN = "4"
TYPE_PARAM = "5"
=======
TYPE_IMPORT = '0'
TYPE_CLASS = '1'
TYPE_FUNCTION = '2'
TYPE_ATTR = '3'
TYPE_BUILTIN = '4'
TYPE_PARAM = '5'
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c


def _imp(name, log=None):
    try:
        return __import__(name)
    except:
<<<<<<< HEAD
        if "." in name:
            sub = name[0 : name.rfind(".")]

            if log is not None:
                log.add_content("Unable to import", name, "trying with", sub)
=======
        if '.' in name:
            sub = name[0:name.rfind('.')]

            if log is not None:
                log.add_content('Unable to import', name, 'trying with', sub)
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                log.add_exception()

            return _imp(sub, log)
        else:
<<<<<<< HEAD
            s = "Unable to import module: %s - sys.path: %s" % (str(name), sys.path)
=======
            s = 'Unable to import module: %s - sys.path: %s' % (str(name), sys.path)
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
            if log is not None:
                log.add_content(s)
                log.add_exception()

            raise ImportError(s)


IS_IPY = False
<<<<<<< HEAD
if sys.platform == "cli":
=======
if sys.platform == 'cli':
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    IS_IPY = True
    _old_imp = _imp

    def _imp(name, log=None):
        # We must add a reference in clr for .Net
        import clr  # @UnresolvedImport
<<<<<<< HEAD

        initial_name = name
        while "." in name:
=======
        initial_name = name
        while '.' in name:
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
            try:
                clr.AddReference(name)
                break  # If it worked, that's OK.
            except:
<<<<<<< HEAD
                name = name[0 : name.rfind(".")]
=======
                name = name[0:name.rfind('.')]
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
        else:
            try:
                clr.AddReference(name)
            except:
                pass  # That's OK (not dot net module).

        return _old_imp(initial_name, log)


def get_file(mod):
    f = None
    try:
        f = inspect.getsourcefile(mod) or inspect.getfile(mod)
    except:
        try:
<<<<<<< HEAD
            f = getattr(mod, "__file__", None)
        except:
            f = None
        if f and f.lower(f[-4:]) in [".pyc", ".pyo"]:
            filename = f[:-4] + ".py"
=======
            f = getattr(mod, '__file__', None)
        except:
            f = None
        if f and f.lower(f[-4:]) in ['.pyc', '.pyo']:
            filename = f[:-4] + '.py'
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
            if os.path.exists(filename):
                f = filename

    return f


def Find(name, log=None):
    f = None

    mod = _imp(name, log)
    parent = mod
<<<<<<< HEAD
    foundAs = ""
=======
    foundAs = ''
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

    if inspect.ismodule(mod):
        f = get_file(mod)

<<<<<<< HEAD
    components = name.split(".")
=======
    components = name.split('.')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

    old_comp = None
    for comp in components[1:]:
        try:
            # this happens in the following case:
            # we have mx.DateTime.mxDateTime.mxDateTime.pyd
            # but after importing it, mx.DateTime.mxDateTime shadows access to mxDateTime.pyd
            mod = getattr(mod, comp)
        except AttributeError:
            if old_comp != comp:
                raise

        if inspect.ismodule(mod):
            f = get_file(mod)
        else:
            if len(foundAs) > 0:
<<<<<<< HEAD
                foundAs = foundAs + "."
=======
                foundAs = foundAs + '.'
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
            foundAs = foundAs + comp

        old_comp = comp

    return f, mod, parent, foundAs


def search_definition(data):
<<<<<<< HEAD
    """@return file, line, col"""

    data = data.replace("\n", "")
    if data.endswith("."):
        data = data.rstrip(".")
=======
    '''@return file, line, col
    '''

    data = data.replace('\n', '')
    if data.endswith('.'):
        data = data.rstrip('.')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    f, mod, parent, foundAs = Find(data)
    try:
        return do_find(f, mod), foundAs
    except:
        return do_find(f, parent), foundAs


def generate_tip(data, log=None):
<<<<<<< HEAD
    data = data.replace("\n", "")
    if data.endswith("."):
        data = data.rstrip(".")
=======
    data = data.replace('\n', '')
    if data.endswith('.'):
        data = data.rstrip('.')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

    f, mod, parent, foundAs = Find(data, log)
    # print_ >> open('temp.txt', 'w'), f
    tips = generate_imports_tip_for_module(mod)
    return f, tips


def check_char(c):
<<<<<<< HEAD
    if c == "-" or c == ".":
        return "_"
=======
    if c == '-' or c == '.':
        return '_'
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    return c


_SENTINEL = object()


<<<<<<< HEAD
def generate_imports_tip_for_module(obj_to_complete, dir_comps=None, getattr=getattr, filter=lambda name: True):
    """
    @param obj_to_complete: the object from where we should get the completions
    @param dir_comps: if passed, we should not 'dir' the object and should just iterate those passed as kwonly_arg parameter
    @param getattr: the way to get kwonly_arg given object from the obj_to_complete (used for the completer)
    @param filter: kwonly_arg callable that receives the name and decides if it should be appended or not to the results
    @return: list of tuples, so that each tuple represents kwonly_arg completion with:
        name, doc, args, type (from the TYPE_* constants)
    """
=======
def generate_imports_tip_for_module(obj_to_complete, dir_comps=None, getattr=getattr, filter=lambda name:True):
    '''
        @param obj_to_complete: the object from where we should get the completions
        @param dir_comps: if passed, we should not 'dir' the object and should just iterate those passed as kwonly_arg parameter
        @param getattr: the way to get kwonly_arg given object from the obj_to_complete (used for the completer)
        @param filter: kwonly_arg callable that receives the name and decides if it should be appended or not to the results
        @return: list of tuples, so that each tuple represents kwonly_arg completion with:
            name, doc, args, type (from the TYPE_* constants)
    '''
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    ret = []

    if dir_comps is None:
        dir_comps = dir_checked(obj_to_complete)
<<<<<<< HEAD
        if hasattr_checked(obj_to_complete, "__dict__"):
            dir_comps.append("__dict__")
        if hasattr_checked(obj_to_complete, "__class__"):
            dir_comps.append("__class__")
=======
        if hasattr_checked(obj_to_complete, '__dict__'):
            dir_comps.append('__dict__')
        if hasattr_checked(obj_to_complete, '__class__'):
            dir_comps.append('__class__')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

    get_complete_info = True

    if len(dir_comps) > 1000:
        # ok, we don't want to let our users wait forever...
        # no complete info for you...

        get_complete_info = False

    dontGetDocsOn = (float, int, str, tuple, list, dict)
    dontGetattrOn = (dict, list, set, tuple)
    for d in dir_comps:
<<<<<<< HEAD
=======

>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
        if d is None:
            continue

        if not filter(d):
            continue

<<<<<<< HEAD
        args = ""
=======
        args = ''
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

        try:
            try:
                if isinstance(obj_to_complete, dontGetattrOn):
<<<<<<< HEAD
                    raise Exception(
                        'Since python 3.9, e.g. "dict[str]" will return'
                        " a dict that's only supposed to take strings. "
                        'Interestingly, e.g. dict["val"] is also valid '
                        "and presumably represents a dict that only takes "
                        'keys that are "val". This breaks our check for '
                        "class attributes."
                    )
=======
                    raise Exception('Since python 3.9, e.g. "dict[str]" will return'
                                    " a dict that's only supposed to take strings. "
                                    'Interestingly, e.g. dict["val"] is also valid '
                                    'and presumably represents a dict that only takes '
                                    'keys that are "val". This breaks our check for '
                                    'class attributes.')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                obj = getattr(obj_to_complete.__class__, d)
            except:
                obj = getattr(obj_to_complete, d)
        except:  # just ignore and get it without additional info
<<<<<<< HEAD
            ret.append((d, "", args, TYPE_BUILTIN))
        else:
=======
            ret.append((d, '', args, TYPE_BUILTIN))
        else:

>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
            if get_complete_info:
                try:
                    retType = TYPE_BUILTIN

                    # check if we have to get docs
                    getDoc = True
                    for class_ in dontGetDocsOn:
<<<<<<< HEAD
=======

>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                        if isinstance(obj, class_):
                            getDoc = False
                            break

<<<<<<< HEAD
                    doc = ""
=======
                    doc = ''
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                    if getDoc:
                        # no need to get this info... too many constants are defined and
                        # makes things much slower (passing all that through sockets takes quite some time)
                        try:
                            doc = inspect.getdoc(obj)
                            if doc is None:
<<<<<<< HEAD
                                doc = ""
                        except:  # may happen on jython when checking java classes (so, just ignore it)
                            doc = ""
=======
                                doc = ''
                        except:  # may happen on jython when checking java classes (so, just ignore it)
                            doc = ''
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

                    if inspect.ismethod(obj) or inspect.isbuiltin(obj) or inspect.isfunction(obj) or inspect.isroutine(obj):
                        try:
                            args, vargs, kwargs, defaults, kwonly_args, kwonly_defaults = getargspec(obj)

                            args = args[:]

                            for kwonly_arg in kwonly_args:
                                default = kwonly_defaults.get(kwonly_arg, _SENTINEL)
                                if default is not _SENTINEL:
<<<<<<< HEAD
                                    args.append("%s=%s" % (kwonly_arg, default))
                                else:
                                    args.append(str(kwonly_arg))

                            args = "(%s)" % (", ".join(args))
                        except TypeError:
                            # ok, let's see if we can get the arguments from the doc
                            args, doc = signature_from_docstring(doc, getattr(obj, "__name__", None))
=======
                                    args.append('%s=%s' % (kwonly_arg, default))
                                else:
                                    args.append(str(kwonly_arg))

                            args = '(%s)' % (', '.join(args))
                        except TypeError:
                            # ok, let's see if we can get the arguments from the doc
                            args, doc = signature_from_docstring(doc, getattr(obj, '__name__', None))
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

                        retType = TYPE_FUNCTION

                    elif inspect.isclass(obj):
                        retType = TYPE_CLASS

                    elif inspect.ismodule(obj):
                        retType = TYPE_IMPORT

                    else:
                        retType = TYPE_ATTR

                    # add token and doc to return - assure only strings.
                    ret.append((d, doc, args, retType))

                except:  # just ignore and get it without aditional info
<<<<<<< HEAD
                    ret.append((d, "", args, TYPE_BUILTIN))
=======
                    ret.append((d, '', args, TYPE_BUILTIN))
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

            else:  # get_complete_info == False
                if inspect.ismethod(obj) or inspect.isbuiltin(obj) or inspect.isfunction(obj) or inspect.isroutine(obj):
                    retType = TYPE_FUNCTION

                elif inspect.isclass(obj):
                    retType = TYPE_CLASS

                elif inspect.ismodule(obj):
                    retType = TYPE_IMPORT

                else:
                    retType = TYPE_ATTR
                # ok, no complete info, let's try to do this as fast and clean as possible
                # so, no docs for this kind of information, only the signatures
<<<<<<< HEAD
                ret.append((d, "", str(args), retType))
=======
                ret.append((d, '', str(args), retType))
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

    return ret


def signature_from_docstring(doc, obj_name):
<<<<<<< HEAD
    args = "()"
=======
    args = '()'
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    try:
        found = False
        if len(doc) > 0:
            if IS_IPY:
                # Handle case where we have the situation below
                # sort(self, object cmp, object key)
                # sort(self, object cmp, object key, bool reverse)
                # sort(self)
                # sort(self, object cmp)

                # Or: sort(self: list, cmp: object, key: object)
                # sort(self: list, cmp: object, key: object, reverse: bool)
                # sort(self: list)
                # sort(self: list, cmp: object)
                if obj_name:
<<<<<<< HEAD
                    name = obj_name + "("
=======
                    name = obj_name + '('
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

                    # Fix issue where it was appearing sort(aa)sort(bb)sort(cc) in the same line.
                    lines = doc.splitlines()
                    if len(lines) == 1:
                        c = doc.count(name)
                        if c > 1:
<<<<<<< HEAD
                            doc = ("\n" + name).join(doc.split(name))

                    major = ""
                    for line in doc.splitlines():
                        if line.startswith(name) and line.endswith(")"):
                            if len(line) > len(major):
                                major = line
                    if major:
                        args = major[major.index("(") :]
                        found = True

            if not found:
                i = doc.find("->")
                if i < 0:
                    i = doc.find("--")
                    if i < 0:
                        i = doc.find("\n")
                        if i < 0:
                            i = doc.find("\r")
=======
                            doc = ('\n' + name).join(doc.split(name))

                    major = ''
                    for line in doc.splitlines():
                        if line.startswith(name) and line.endswith(')'):
                            if len(line) > len(major):
                                major = line
                    if major:
                        args = major[major.index('('):]
                        found = True

            if not found:
                i = doc.find('->')
                if i < 0:
                    i = doc.find('--')
                    if i < 0:
                        i = doc.find('\n')
                        if i < 0:
                            i = doc.find('\r')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

                if i > 0:
                    s = doc[0:i]
                    s = s.strip()

                    # let's see if we have a docstring in the first line
<<<<<<< HEAD
                    if s[-1] == ")":
                        start = s.find("(")
                        if start >= 0:
                            end = s.find("[")
                            if end <= 0:
                                end = s.find(")")
=======
                    if s[-1] == ')':
                        start = s.find('(')
                        if start >= 0:
                            end = s.find('[')
                            if end <= 0:
                                end = s.find(')')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                                if end <= 0:
                                    end = len(s)

                            args = s[start:end]
<<<<<<< HEAD
                            if not args[-1] == ")":
                                args = args + ")"
=======
                            if not args[-1] == ')':
                                args = args + ')'
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

                            # now, get rid of unwanted chars
                            l = len(args) - 1
                            r = []
                            for i in range(len(args)):
                                if i == 0 or i == l:
                                    r.append(args[i])
                                else:
                                    r.append(check_char(args[i]))

<<<<<<< HEAD
                            args = "".join(r)

            if IS_IPY:
                if args.startswith("(self:"):
                    i = args.find(",")
                    if i >= 0:
                        args = "(self" + args[i:]
                    else:
                        args = "(self)"
                i = args.find(")")
                if i > 0:
                    args = args[: i + 1]
=======
                            args = ''.join(r)

            if IS_IPY:
                if args.startswith('(self:'):
                    i = args.find(',')
                    if i >= 0:
                        args = '(self' + args[i:]
                    else:
                        args = '(self)'
                i = args.find(')')
                if i > 0:
                    args = args[:i + 1]
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

    except:
        pass
    return args, doc
