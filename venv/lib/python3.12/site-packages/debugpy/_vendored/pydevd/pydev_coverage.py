<<<<<<< HEAD
"""
Entry point module to run code-coverage.
"""


def is_valid_py_file(path):
    """
    Checks whether the file can be read by the coverage module. This is especially
    needed for .pyx files and .py files with syntax errors.
    """
    import os

    is_valid = False
    if os.path.isfile(path) and not os.path.splitext(path)[1] == ".pyx":
        try:
            with open(path, "rb") as f:
                compile(f.read(), path, "exec")
=======
'''
Entry point module to run code-coverage.
'''


def is_valid_py_file(path):
    '''
    Checks whether the file can be read by the coverage module. This is especially
    needed for .pyx files and .py files with syntax errors.
    '''
    import os

    is_valid = False
    if os.path.isfile(path) and not os.path.splitext(path)[1] == '.pyx':
        try:
            with open(path, 'rb') as f:
                compile(f.read(), path, 'exec')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                is_valid = True
        except:
            pass
    return is_valid


def execute():
    import os
    import sys

    files = None
<<<<<<< HEAD
    if "combine" not in sys.argv:
        if "--pydev-analyze" in sys.argv:
=======
    if 'combine' not in sys.argv:

        if '--pydev-analyze' in sys.argv:

>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
            # Ok, what we want here is having the files passed through stdin (because
            # there may be too many files for passing in the command line -- we could
            # just pass a dir and make the find files here, but as that's already
            # given in the java side, let's just gather that info here).
<<<<<<< HEAD
            sys.argv.remove("--pydev-analyze")
            s = input()
            s = s.replace("\r", "")
            s = s.replace("\n", "")

            files = []
            invalid_files = []
            for v in s.split("|"):
=======
            sys.argv.remove('--pydev-analyze')
            s = input()
            s = s.replace('\r', '')
            s = s.replace('\n', '')

            files = []
            invalid_files = []
            for v in s.split('|'):
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                if is_valid_py_file(v):
                    files.append(v)
                else:
                    invalid_files.append(v)
            if invalid_files:
<<<<<<< HEAD
                sys.stderr.write("Invalid files not passed to coverage: %s\n" % ", ".join(invalid_files))
=======
                sys.stderr.write('Invalid files not passed to coverage: %s\n'
                                 % ', '.join(invalid_files))
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

            # Note that in this case we'll already be in the working dir with the coverage files,
            # so, the coverage file location is not passed.

        else:
            # For all commands, the coverage file is configured in pydev, and passed as the first
            # argument in the command line, so, let's make sure this gets to the coverage module.
<<<<<<< HEAD
            os.environ["COVERAGE_FILE"] = sys.argv[1]
=======
            os.environ['COVERAGE_FILE'] = sys.argv[1]
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
            del sys.argv[1]

    try:
        import coverage  # @UnresolvedImport
    except:
<<<<<<< HEAD
        sys.stderr.write("Error: coverage module could not be imported\n")
        sys.stderr.write("Please make sure that the coverage module " "(http://nedbatchelder.com/code/coverage/)\n")
        sys.stderr.write("is properly installed in your interpreter: %s\n" % (sys.executable,))

        import traceback

        traceback.print_exc()
        return

    if hasattr(coverage, "__version__"):
        version = tuple(map(int, coverage.__version__.split(".")[:2]))
        if version < (4, 3):
            sys.stderr.write(
                "Error: minimum supported coverage version is 4.3."
                "\nFound: %s\nLocation: %s\n" % (".".join(str(x) for x in version), coverage.__file__)
            )
            sys.exit(1)
    else:
        sys.stderr.write("Warning: Could not determine version of python module coverage." "\nEnsure coverage version is >= 4.3\n")
=======
        sys.stderr.write('Error: coverage module could not be imported\n')
        sys.stderr.write('Please make sure that the coverage module '
                         '(http://nedbatchelder.com/code/coverage/)\n')
        sys.stderr.write('is properly installed in your interpreter: %s\n' % (sys.executable,))

        import traceback;traceback.print_exc()
        return

    if hasattr(coverage, '__version__'):
        version = tuple(map(int, coverage.__version__.split('.')[:2]))
        if version < (4, 3):
            sys.stderr.write('Error: minimum supported coverage version is 4.3.'
                             '\nFound: %s\nLocation: %s\n'
                             % ('.'.join(str(x) for x in version), coverage.__file__))
            sys.exit(1)
    else:
        sys.stderr.write('Warning: Could not determine version of python module coverage.'
                         '\nEnsure coverage version is >= 4.3\n')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

    from coverage.cmdline import main  # @UnresolvedImport

    if files is not None:
<<<<<<< HEAD
        sys.argv.append("xml")
=======
        sys.argv.append('xml')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
        sys.argv += files

    main()


<<<<<<< HEAD
if __name__ == "__main__":
=======
if __name__ == '__main__':
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    execute()
