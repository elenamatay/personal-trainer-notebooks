from _pydev_bundle.pydev_imports import xmlrpclib, _queue
<<<<<<< HEAD

=======
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
Queue = _queue.Queue
import traceback
import sys
from _pydev_runfiles.pydev_runfiles_coverage import start_coverage_support_from_params
import threading


<<<<<<< HEAD
# =======================================================================================================================
# ParallelNotification
# =======================================================================================================================
class ParallelNotification(object):
=======
#=======================================================================================================================
# ParallelNotification
#=======================================================================================================================
class ParallelNotification(object):

>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    def __init__(self, method, args, kwargs):
        self.method = method
        self.args = args
        self.kwargs = kwargs

    def to_tuple(self):
        return self.method, self.args, self.kwargs


<<<<<<< HEAD
# =======================================================================================================================
# KillServer
# =======================================================================================================================
=======
#=======================================================================================================================
# KillServer
#=======================================================================================================================
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
class KillServer(object):
    pass


<<<<<<< HEAD
# =======================================================================================================================
# ServerComm
# =======================================================================================================================
class ServerComm(threading.Thread):
    def __init__(self, job_id, server):
        self.notifications_queue = Queue()
        threading.Thread.__init__(self)
        self.setDaemon(False)  # Wait for all the notifications to be passed before exiting!
=======

#=======================================================================================================================
# ServerComm
#=======================================================================================================================
class ServerComm(threading.Thread):



    def __init__(self, job_id, server):
        self.notifications_queue = Queue()
        threading.Thread.__init__(self)
        self.setDaemon(False) #Wait for all the notifications to be passed before exiting!
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
        assert job_id is not None
        assert port is not None
        self.job_id = job_id

        self.finished = False
        self.server = server

<<<<<<< HEAD
=======

>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    def run(self):
        while True:
            kill_found = False
            commands = []
            command = self.notifications_queue.get(block=True)
            if isinstance(command, KillServer):
                kill_found = True
            else:
                assert isinstance(command, ParallelNotification)
                commands.append(command.to_tuple())

            try:
                while True:
<<<<<<< HEAD
                    command = self.notifications_queue.get(block=False)  # No block to create a batch.
=======
                    command = self.notifications_queue.get(block=False) #No block to create a batch.
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                    if isinstance(command, KillServer):
                        kill_found = True
                    else:
                        assert isinstance(command, ParallelNotification)
                        commands.append(command.to_tuple())
            except:
<<<<<<< HEAD
                pass  # That's OK, we're getting it until it becomes empty so that we notify multiple at once.

            if commands:
                try:
                    # Batch notification.
=======
                pass #That's OK, we're getting it until it becomes empty so that we notify multiple at once.


            if commands:
                try:
                    #Batch notification.
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                    self.server.lock.acquire()
                    try:
                        self.server.notifyCommands(self.job_id, commands)
                    finally:
                        self.server.lock.release()
                except:
                    traceback.print_exc()

            if kill_found:
                self.finished = True
                return


<<<<<<< HEAD
# =======================================================================================================================
# ServerFacade
# =======================================================================================================================
class ServerFacade(object):
    def __init__(self, notifications_queue):
        self.notifications_queue = notifications_queue

    def notifyTestsCollected(self, *args, **kwargs):
        pass  # This notification won't be passed

    def notifyTestRunFinished(self, *args, **kwargs):
        pass  # This notification won't be passed

    def notifyStartTest(self, *args, **kwargs):
        self.notifications_queue.put_nowait(ParallelNotification("notifyStartTest", args, kwargs))

    def notifyTest(self, *args, **kwargs):
        self.notifications_queue.put_nowait(ParallelNotification("notifyTest", args, kwargs))


# =======================================================================================================================
# run_client
# =======================================================================================================================
=======

#=======================================================================================================================
# ServerFacade
#=======================================================================================================================
class ServerFacade(object):


    def __init__(self, notifications_queue):
        self.notifications_queue = notifications_queue


    def notifyTestsCollected(self, *args, **kwargs):
        pass #This notification won't be passed


    def notifyTestRunFinished(self, *args, **kwargs):
        pass #This notification won't be passed


    def notifyStartTest(self, *args, **kwargs):
        self.notifications_queue.put_nowait(ParallelNotification('notifyStartTest', args, kwargs))


    def notifyTest(self, *args, **kwargs):
        self.notifications_queue.put_nowait(ParallelNotification('notifyTest', args, kwargs))



#=======================================================================================================================
# run_client
#=======================================================================================================================
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
def run_client(job_id, port, verbosity, coverage_output_file, coverage_include):
    job_id = int(job_id)

    from _pydev_bundle import pydev_localhost
<<<<<<< HEAD

    server = xmlrpclib.Server("http://%s:%s" % (pydev_localhost.get_localhost(), port))
    server.lock = threading.Lock()

=======
    server = xmlrpclib.Server('http://%s:%s' % (pydev_localhost.get_localhost(), port))
    server.lock = threading.Lock()


>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    server_comm = ServerComm(job_id, server)
    server_comm.start()

    try:
        server_facade = ServerFacade(server_comm.notifications_queue)
        from _pydev_runfiles import pydev_runfiles
        from _pydev_runfiles import pydev_runfiles_xml_rpc
<<<<<<< HEAD

        pydev_runfiles_xml_rpc.set_server(server_facade)

        # Starts None and when the 1st test is gotten, it's started (because a server may be initiated and terminated
        # before receiving any test -- which would mean a different process got all the tests to run).
=======
        pydev_runfiles_xml_rpc.set_server(server_facade)

        #Starts None and when the 1st test is gotten, it's started (because a server may be initiated and terminated
        #before receiving any test -- which would mean a different process got all the tests to run).
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
        coverage = None

        try:
            tests_to_run = [1]
            while tests_to_run:
<<<<<<< HEAD
                # Investigate: is it dangerous to use the same xmlrpclib server from different threads?
                # It seems it should be, as it creates a new connection for each request...
=======
                #Investigate: is it dangerous to use the same xmlrpclib server from different threads?
                #It seems it should be, as it creates a new connection for each request...
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                server.lock.acquire()
                try:
                    tests_to_run = server.GetTestsToRun(job_id)
                finally:
                    server.lock.release()

                if not tests_to_run:
                    break

                if coverage is None:
<<<<<<< HEAD
                    _coverage_files, coverage = start_coverage_support_from_params(None, coverage_output_file, 1, coverage_include)

                files_to_tests = {}
                for test in tests_to_run:
                    filename_and_test = test.split("|")
=======
                    _coverage_files, coverage = start_coverage_support_from_params(
                        None, coverage_output_file, 1, coverage_include)


                files_to_tests = {}
                for test in tests_to_run:
                    filename_and_test = test.split('|')
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                    if len(filename_and_test) == 2:
                        files_to_tests.setdefault(filename_and_test[0], []).append(filename_and_test[1])

                configuration = pydev_runfiles.Configuration(
<<<<<<< HEAD
                    "",
=======
                    '',
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                    verbosity,
                    None,
                    None,
                    None,
                    files_to_tests,
<<<<<<< HEAD
                    1,  # Always single job here
                    None,
                    # The coverage is handled in this loop.
=======
                    1, #Always single job here
                    None,

                    #The coverage is handled in this loop.
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
                    coverage_output_file=None,
                    coverage_include=None,
                )
                test_runner = pydev_runfiles.PydevTestRunner(configuration)
                sys.stdout.flush()
                test_runner.run_tests(handle_coverage=False)
        finally:
            if coverage is not None:
                coverage.stop()
                coverage.save()

<<<<<<< HEAD
=======

>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
    except:
        traceback.print_exc()
    server_comm.notifications_queue.put_nowait(KillServer())


<<<<<<< HEAD
# =======================================================================================================================
# main
# =======================================================================================================================
if __name__ == "__main__":
    if len(sys.argv) - 1 == 3:
        job_id, port, verbosity = sys.argv[1:]
        coverage_output_file, coverage_include = None, None

    elif len(sys.argv) - 1 == 5:
        job_id, port, verbosity, coverage_output_file, coverage_include = sys.argv[1:]

    else:
        raise AssertionError("Could not find out how to handle the parameters: " + sys.argv[1:])
=======

#=======================================================================================================================
# main
#=======================================================================================================================
if __name__ == '__main__':
    if len(sys.argv) -1 == 3:
        job_id, port, verbosity = sys.argv[1:]
        coverage_output_file, coverage_include = None, None

    elif len(sys.argv) -1 == 5:
        job_id, port, verbosity, coverage_output_file, coverage_include = sys.argv[1:]

    else:
        raise AssertionError('Could not find out how to handle the parameters: '+sys.argv[1:])
>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c

    job_id = int(job_id)
    port = int(port)
    verbosity = int(verbosity)
    run_client(job_id, port, verbosity, coverage_output_file, coverage_include)
<<<<<<< HEAD
=======


>>>>>>> 18d7037cf30f05fb9c835180cb251f94a7f2d64c
